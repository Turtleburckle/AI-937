from random import *
import numpy as np
from copy import deepcopy

from lab3.model import Gene, Directions


class IndividualClass:

    def __init__(self, mutationProbability, crossoverProbability, myMap, battery):
        self.__mutationProbability = mutationProbability
        self.__crossoverProbability = crossoverProbability
        self.__myMap = myMap
        self.battery = battery
        self.directions = Directions.DirectionsClass()
        self.__genes = self.generateGenesForIndividual()
        self.fitnessValue = 0.0
        self.path = []
        self.goodPath = []

    # For each individual a set of genes is generated randomly.
    def generateGenesForIndividual(self):
        gene = Gene.GeneClass()
        gene.generateRandomGene(self.battery)
        return gene.getGene()

    # Getter for the path of the individual.
    def getGenePath(self):
        return self.path

    # Setter for the path of the individual.
    def setGenePath(self, path):
        self.path = path

    # Calculates the fitness of an individual by recreating the path generated by the genes.
    # A higher fitness means that a gene path is mostly doable.
    def fitness(self):
        path = self.pathGenes()
        markedMap = np.zeros((self.__myMap.n, self.__myMap.m))
        self.goodPath.clear()
        self.goodPath = []
        for position in path:
            if 0 < position[0] < self.__myMap.n and 0 < position[1] < self.__myMap.m:
                if self.__myMap.surface[position[0]][position[1]] != 1:
                    if len(self.goodPath) == 0:
                        markedMap[position[0]][position[1]] = 1
                        self.goodPath.append(position)
                    elif self.__myMap.areNeighbors(self.goodPath[len(self.goodPath)-1], position):
                        markedMap[position[0]][position[1]] = 1
                        self.goodPath.append(position)
        self.fitnessValue = np.sum(markedMap)
        #print(self.fitnessValue)
        self.path = path

    def getGoodPath(self):
        print(self.path)
        print(self.goodPath)
        return self.goodPath


    # The mutation shuffles the genes of an individual randomly.
    def mutation(self):
        if random() < self.__mutationProbability and len(self.__genes) >= 2:
            i = 0
            j = 0
            while i == j:
                i = randint(0, len(self.__genes)-1)
                j = randint(0, len(self.__genes)-1)
            self.__genes[i], self.__genes[j] = self.__genes[j], self.__genes[i]

    # The crossover breeds the individual with another one generating two offsprings.
    def crossover(self, otherParent):
        randomFloatNumber = float(random())
        if randomFloatNumber < self.__crossoverProbability:
            cutting_point = randint(0, self.battery)
            newGene = []
            for index in range(self.battery):
                if index < cutting_point:
                    newGene.append(self.path[index])
                else:
                    newGene.append(otherParent.getGenePath()[index])
            offspring1 = IndividualClass(self.__mutationProbability,
                                         self.__crossoverProbability,
                                         self.__myMap, self.battery)
            offspring1.setGenePath(self.path)
            offspring1.fitness()
            offspring2 = IndividualClass(self.__mutationProbability,
                                         self.__crossoverProbability,
                                         self.__myMap,
                                         self.battery)
            offspring2.setGenePath(newGene)
            offspring2.fitness()
        else:
            offspring1 = IndividualClass(self.__mutationProbability, self.__crossoverProbability, self.__myMap, self.battery)
            offspring1.setGenePath(self.path)
            offspring1.fitness()
            offspring2 = otherParent
        return offspring1, offspring2

    # Generates the path accordingly to the genes.
    def pathGenes(self):
        path = []
        dronePosition = self.__myMap.getDronePosition()
        path.append(dronePosition)
        x = dronePosition[0]
        y = dronePosition[1]
        for gene in self.__genes:
            if gene == self.directions.getUp():
                xCurrent = x - 1
                yCurrent = y
            elif gene == self.directions.getDown():
                xCurrent = x + 1
                yCurrent = y
            elif gene == self.directions.getLeft():
                xCurrent = x
                yCurrent = y - 1
            elif gene == self.directions.getRight():
                xCurrent = x
                yCurrent = y + 1
            path.append((xCurrent, yCurrent))
            x = xCurrent
            y = yCurrent
        return path

    def __str__(self):
        return str(self.fitnessValue)

